class UnionFind:

    def __init__(self, n):
        self.rank = [1] * n
        self.parent = [i for i in range(n)]

    def find(self, x):
        while x != self.parent[x]:
            x = self.parent[self.parent[x]]
        return x

    def union(self, x, y):
        x_root = self.find(x)
        y_root = self.find(y)
        if x_root == y_root:
            return
        if self.rank[x_root] > self.rank[y_root]:
            self.rank[x_root] += self.rank[y_root]
            self.parent[y_root] = x_root
        else:
            self.rank[y_root] += self.rank[x_root]
            self.parent[x_root] = y_root
        
        return 

    # find group size 
    def size(self, x):
        return self.rank[self.find(x)]

"""
这一题就是要找出一个group里面只有一个被感染的节点

，然后这个group里面的节点数最多。
UnionFind 函数里面还加了 size 
"""

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        uf = UnionFind(len(graph))

        # O(N^2)
        for j, row in enumerate(graph):
            for i in range(len(row)):
                if row[i]:
                    uf.union(j, i)
        
        # count each group how many infected nodes have
        count = Counter(uf.find(u) for u in initial)
        initial.sort()
        # try to find group with only one infect nodes
        ans = (-1, initial[0])

        for node in initial:
            root = uf.find(node)
            if count[root] == 1:
                if uf.size(root) > ans[0]:
                    ans = (uf.size(root), node)

        return ans[1]